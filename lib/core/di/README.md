# Dependency Injection

This directory contains the dependency injection setup using `get_it` and `injectable`.

## Files

- `injection.dart` - Main DI configuration and service locator
- `injection.config.dart` - Auto-generated by `build_runner`
- `network_module.dart` - Provides HTTP client (Dio) and Logger

## Usage

### Initialization

Dependency injection is initialized in `main.dart`:

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize DI
  await configureDependencies();

  runApp(MyApp());
}
```

### Registering Dependencies

Use `@injectable` annotation to register classes:

```dart
import 'package:injectable/injectable.dart';

@injectable
class MyService {
  final Dio dio;

  MyService(this.dio);

  Future<void> fetchData() async {
    final response = await dio.get('/api/data');
    return response.data;
  }
}
```

### Accessing Dependencies

```dart
import 'package:crossplatform_totalnba/core/di/injection.dart';

// Get instance
final myService = getIt<MyService>();
await myService.fetchData();
```

### Available Services

#### Dio (HTTP Client)
```dart
final dio = getIt<Dio>();
final response = await dio.get('/api/endpoint');
```

#### Logger
```dart
final logger = getIt<Logger>();
logger.d('Debug message');
logger.i('Info message');
logger.w('Warning message');
logger.e('Error message');
```

## Scopes

### @lazySingleton
Creates a single instance when first accessed:

```dart
@lazySingleton
class ApiService {
  final Dio dio;
  ApiService(this.dio);
}
```

### @singleton
Creates a single instance immediately at startup:

```dart
@singleton
class ConfigService {
  final String apiKey;
  ConfigService(this.apiKey);
}
```

### @injectable
Creates a new instance every time it's requested:

```dart
@injectable
class TemporaryService {
  // New instance each time
}
```

## Modules

Modules provide dependencies that can't use @injectable (like external packages):

```dart
@module
abstract class MyModule {
  @lazySingleton
  SharedPreferences provideSharedPreferences() {
    return SharedPreferences.getInstance();
  }
}
```

### Network Module

The `NetworkModule` provides:

**Dio with:**
- Base URL from environment config
- Automatic retry on timeout (up to 3 attempts)
- Request/response logging (in dev/staging only)
- 60-second timeouts
- JSON content type headers

**Logger with:**
- Pretty printing
- Environment-specific log levels
- Timestamps
- Emoji support

## Code Generation

After adding/modifying dependencies, run:

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

This generates `injection.config.dart`.

## Testing

Mock dependencies in tests:

```dart
import 'package:mockito/mockito.dart';

class MockDio extends Mock implements Dio {}

void main() {
  setUp(() {
    // Replace real Dio with mock
    getIt.registerSingleton<Dio>(MockDio());
  });

  tearDown(() {
    getIt.reset();
  });

  test('my test', () {
    final service = getIt<MyService>();
    // Test with mocked Dio
  });
}
```

## Best Practices

1. **Use constructor injection** - Let get_it inject dependencies automatically
2. **Prefer lazy singletons** - Only create instances when needed
3. **Keep modules focused** - One module per concern (network, storage, etc.)
4. **Don't access getIt directly in widgets** - Use Riverpod providers instead
5. **Run code generation** - After any DI changes

## Example: Complete Service

```dart
import 'package:dio/dio.dart';
import 'package:injectable/injectable.dart';
import 'package:logger/logger.dart';

@injectable
class PredictionService {
  final Dio _dio;
  final Logger _logger;

  PredictionService(this._dio, this._logger);

  Future<List<Prediction>> getAllPredictions() async {
    try {
      _logger.d('Fetching all predictions');
      final response = await _dio.get('/api/prediction/all-prediction/');
      return (response.data as List)
          .map((json) => Prediction.fromJson(json))
          .toList();
    } catch (e, stackTrace) {
      _logger.e('Error fetching predictions', error: e, stackTrace: stackTrace);
      rethrow;
    }
  }
}
```

Usage in repository:
```dart
@injectable
class PredictionRepository {
  final PredictionService _service;

  PredictionRepository(this._service);

  Future<List<Prediction>> getPredictions() {
    return _service.getAllPredictions();
  }
}
```

Usage with Riverpod:
```dart
@riverpod
PredictionRepository predictionRepository(PredictionRepositoryRef ref) {
  return getIt<PredictionRepository>();
}
```
